function [QU, Y, iter,k,m,errest] = two_pass_lanc_util(mult,c,normc,options, v1, v2, alphain, betain, H) 


tol = options.tol;
xi = options.xi;
m = options.m;
n = size(c,1);
k = length(xi);
itin = m + 2*k; % number of iterations
errest = [];

% set rational Krylov to compute real basis
options = [];
options.isreal = 1;

% if the first pass has not been computed using full orth because poles or
% extreme eigenvalues are provided, the first pass is performed without
% full orthogonalization
if nargin < 5
    [~, v1, v2, alpha, beta] = generate_Q(mult, itin, zeros(n,1), c/normc, 0);
else
    alpha = alphain;
    beta = betain;
end

% T is the tridiagonal matrix generated by Lanczos iterations
T = spdiags([[beta(1:(itin-1));0],alpha, [0;beta(1:(itin-1))]], -1:1, itin,itin);

% U orthonormal basis of Q(T_1, e_1, xi)
U = rational_krylov(T, double(1:itin == 1)', xi, options);

% final projected matrix
ProjMat = U' * T * U;
ProjMat = (ProjMat + ProjMat')/2;

% solve the projected equation
Y = lyap(ProjMat, -normc^2*( U(1,:)' * U(1,:))); 
Y = (Y + Y')/2;

% estimate residual norm
err = sqrt(2)*beta(end) * norm( U(end,:) * Y, 'fro')/normc^2;

% keep track of number of iterations and error
iter = itin;

errest = [errest; [iter, err]];

% if err is larger than tol, proceed with Lanczos
if err >= tol/sqrt(2)
while iter + m < n
    
    % keep track of number of iterations
    iter = iter + m;

    % retrieve the already computed next beta coefficient
    last_beta = beta(end);

    % extend the basis
    [~, v1, v2, alpha, beta] = generate_Q(mult, m, v1, v2, beta(end));

    That = spdiags([[beta((1:(m-1)));0],alpha, [0;beta((1:(m-1)))]], -1:1, m,m);
    
    % extend tridiagonal matrix
    T = blkdiag(T,That);
    T(end-m, end-m+1)= last_beta;
    T(end-m+1,end-m) = last_beta;

    % U orthonormal basis of Q(T, e_1, xi)
    U = rational_krylov(T,double(1:iter == 1)',xi, options);

    % final projected matrix
    ProjMat = U' * T * U;
    ProjMat = (ProjMat + ProjMat')/2;

    % solve the projected equation
    Y = lyap(ProjMat, -normc^2*U(1,:)'*U(1,:));
    Y = (Y + Y')/2;

    % estimate residual norm
    err = sqrt(2)*beta(end)*norm( U(end,:) * Y, 'fro')/normc^2;

    errest = [errest; [iter, err]];

    % if norm of the residual is smaller than tolerance, end Lanczos
    if err <= tol/sqrt(2)
        break
    end
end

% retrive all the alpha and beta coefficients
last_beta = beta(end);
alpha = full(diag(T));
beta = full(diag(T, -1));
beta = [beta;last_beta];


QU = 0;
s = floor(iter/itin);

% perform the second Lanczos pass generating m + 2k vectorts at a time
for j = 1:s 
    if j == 1
        if nargin < 5
            [Q, v1, v2, ~, ~] = generate_Q(mult, itin, zeros(n,1), c/normc, 0, beta(1:itin), alpha(1:itin));
        else
            % if the first pass was computed with full orth, then full orth is employed again
            [Q, v1, v2, ~] = full_orth_Arnoldi(mult, itin, c/normc, H);
        end
        
    else
        [Q, v1, v2, ~, ~] = generate_Q(mult, itin, v1, v2, beta((j-1)*itin), beta((j-1)*itin + 1 : j*itin), alpha((j-1)*itin + 1 : j*itin));
    end
    QU = QU + Q * U((j-1)*itin + 1 : j*itin, :);
end

if iter - s * itin > 0
    [Q,~,~,~,~] = generate_Q(mult, iter-s*itin, v1, v2, beta(s*itin), beta(s*itin + 1 : end), alpha(s*itin + 1 : end));
    QU = QU + Q * U(s*itin+1:end, :);
end

end