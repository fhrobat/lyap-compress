function [U, Y, iter, k, m, errest] = lyap_compress_util(mult,c,norma,options, Q, v1, v2, alpha, beta) 

tol = options.tol;
xi = options.xi;
m = options.m;
n = size(c,1);
true_res = options.true_res;
k = length(xi);
itin = m + 2*k; % number of iterations
errest = [];

% set rational Krylov to compute real basis
options = [];
options.isreal = 1;

% if the first pass has not been computed using full orth because poles or
% extreme eigenvalues are provided, the first pass is performed without
% full orthogonalization
if nargin < 5
    [Q, v1, v2, alpha, beta] = generate_Q(mult, itin, zeros(n,1), c/norma, 0);
end

% T is the tridiagonal matrix generated by Lanczos iterations
T = spdiags([[beta(1:(itin-1));0],alpha, [0;beta(1:(itin-1))]], -1:1, itin,itin);

% W orthonormal basis of Q(T_1, [e_1, e_(m+2k)], xi]
W = rational_krylov_block(T, [double(1:itin == 1)', double(1:itin == itin)'], xi, options);

% Wtilde is equal to W for the first cycle
Wtilde = W;

% Stilde is computed directly projecting T
Stilde = W' * T * W;
Stilde = (Stilde + Stilde')/2;

% first row of W
w = W(1,:)';

% rational Krylov subspace with one vector
Utilde = rational_krylov(Stilde, w, xi, options);

% final projected matrix
ProjMat = Utilde' * Stilde * Utilde;
ProjMat = (ProjMat + ProjMat')/2;

% solve the projected equation
Y = lyap(ProjMat, -norma^2*( (Utilde' * w) * (Utilde' * w)')); 
Y = (Y + Y')/2;

% estimate residual norm
err = sqrt(2)*beta(end) * norm( (Wtilde(end,:) * Utilde) * Y, 'fro')/norma^2;

% keep track of number of iterations and error
iter = itin;

if true_res
        U = Q * (W * Utilde);
        [~, Rsx] = qr([mult(U) * Y,  U, c], 'econ');
        [~, Rdx] = qr([U, mult(U) * Y, -c], 'econ');
        error = norm(Rsx * Rdx', 'fro')/norma^2;
        errest = [iter,err, error];
else
    errest = [errest; [iter, err]];
end

% if err is larger than tol, proceed with Lanczos
if err >= tol/sqrt(2)

% compress basis
comp_basis = Q * W;

while iter + m < n
    
    % retrieve the last beta coefficient
    last_beta = beta(end);

    % extend the basis
    [Q, v1, v2, alpha, beta] = generate_Q(mult, m, v1, v2, beta(end));

    % needed in case rational Krylov performs a deflation
    dim = size(w,1); 
    
    % extend tridiagonal matrix T
    That = spdiags([[beta((1:(m-1)));0],alpha, [0;beta((1:(m-1)))]], -1:1, m,m);
    
    % form the matrix S
    block = [last_beta * Wtilde(end,:); zeros(m-1,dim)];
    S = [Stilde, block'; block, That];
   
    % Wtilde orthonormal basis of Q(S, [w;0 , 0;e_m], xi)
    Wtilde= rational_krylov_block(S, [ [w; zeros(m,1)], double(1:(dim + m) == (dim + m))' ], xi, options);
    
    % project T into W by projecting S
    Stilde = Wtilde' * S * Wtilde; 
    Stilde = (Stilde + Stilde')/2;
    
    % update w
    w = Wtilde' * [w; zeros(m,1)];

    % rational Krylov subspace with one vector
    Utilde = rational_krylov(Stilde, w, xi, options);

    % final projected matrix
    ProjMat = Utilde' * Stilde * Utilde;
    ProjMat = (ProjMat + ProjMat')/2;
    
    % solve the projected equation
    Y = lyap(ProjMat, -norma^2*( (Utilde' * w) * (Utilde' * w)'));
    Y = (Y + Y')/2;

    % estimate residual norm
    err = sqrt(2)*beta(end)*norm((Wtilde(end,:) * Utilde) * Y, 'fro')/norma^2;

    % keep track of number of iterations and error
    iter = iter + m;

    % true norm of the residual
    if true_res
        U = [comp_basis,Q] * (Wtilde * Utilde);
        [~, Rsx] = qr([mult(U) * Y,  U, c], 'econ');
        [~, Rdx] = qr([U, mult(U) * Y, -c], 'econ');
        error = norm(Rsx * Rdx', 'fro')/norma^2;
        errest(end+1, :) = [iter,err, error];
    else
        errest = [errest; [iter, err]];
    end

    % if norm of the residual is smaller than tolerance, end Lanczos
    if err <= tol/sqrt(2)
        break
    end

    % compress basis
    comp_basis = [comp_basis,Q] * Wtilde;
end
end

% return the final compressed basis
if ~true_res
    U = [comp_basis,Q] * (Wtilde * Utilde);
end
end